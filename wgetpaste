#!/bin/bash
# A Script that automates pasting to a number of pastebin services
# relying only on bash, sed, coreutils (mktemp/sort/tr/wc/whoami) and wget
# Copyright (c) 2007 Bo Ã˜rsted Andresen <bo.andresen@zlin.dk>
# Distributed as-is. With no warranties.

VERSION="9999"

### helper functions

# show error message(s) and die
die() {
	echo "$@" >&2
	exit 1
}

# escape % (used for escaping), & (used as separator in POST data), + (used as space in POST data) and space
escape() {
	sed -e 's|%|%25|g' -e 's|&|%26|g' -e 's|+|%2b|g' -e 's| |+|g' <<< "$*"
}	

showurl() {
	[[ function == $(type -t add_to_clipboard) ]] && add_to_clipboard "$1"
	echo "Your ${2}paste can be seen here: ${1}"
}

# Used for --info and --info-only
INFO_COMMAND="emerge --info"
INFO_ARGS="--ignore-default-opts"

### service definitions

SERVICES=(ca rafb osl sh)

# ENGINE URL RAW EXPIRE_INFO
ca=(ca http://pastebin.ca/)
rafb=(rafb http://rafb.net/paste/ paste.php "Pastes on rafb: http://rafb.net/paste/ expire after 24 hours.\n")
osl=(osl http://pastebin.osuosl.org/ pastebin.php)
sh=(sh http://sh.nu/p/)

### engine definitions

# languages
ca_LANGUAGES=(Plain\ Text Asterisk\ Configuration C C++ PHP Perl Java VB C\# Ruby Python Pascal \
mIRC PL/I XML SQL Scheme ActionScript Ada Apache\ Configuration Assembly\ \(NASM\) ASP Bash CSS \
Delphi HTML\ 4\.0\ Strict JavaScript LISP Lua Microprocessor\ ASM Objective\ C VB\.NET)
ca_LANGUAGE_COUNT=0
rafb_LANGUAGES=(C C89 C99 C++ C\# Java Pascal Perl PHP PL\/I Python Ruby SQL VB Plain\ Text)
osl_LANGUAGES=(Plain\ Text ActionScript Ada Apache\ Log\ File AppleScript Assembly\ \(NASM\) \
ASP Bash C C\ for\ Macs CAD\ DCL CAD\ Lisp C++ C\# ColdFusion CSS D Delphi Diff DOS Eiffel Fortran \
FreeBasic Game\ Maker HTML\ 4\.0\ Strict INI\ file Java Javascript Lisp Lua MatLab Microprocessor\ ASM \
MySQL NullSoft\ Installer Objective\ C OCaml Openoffice\.org\ BASIC Oracle\ 8 Pascal Perl PHP Python \
QBasic Robots\.txt Ruby Scheme Smarty SQL TCL VB VB\.NET VisualFoxPro XML)
osl_LANGUAGE_VALUES=(text actionscript ada apache applescript asm asp bash c c\ mac caddcl \
cadlisp cpp csharp cfm css d delphi diff dos eiffel fortran freebasic gml html4strict ini java \
javascript lisp lua matlab mpasm mysql nsis objc ocaml oobas oracle8 pascal perl php python \
qbasic robots ruby scheme smarty sql tcl vb vbnet visualfoxpro xml)
# expirations
ca_EXPIRATIONS=(Never 5\ minutes 10\ minutes 15\ minutes 30\ minutes 45\ minutes 1\ hour 2\ hours \
4\ hours 8\ hours 12\ hours 1\ day 2\ days 3\ days 1\ week 2\ weeks 3\ weeks 1\ month 2\ months \
3\ months 4\ months 5\ months 6\ months 1\ year)
osl_EXPIRATIONS=(Never 1\ day 1\ month)
osl_EXPIRATION_VALUES=(f d m)
# warns - max_bytes human_readable max_lines known_failure known_failure_message known_failure2 known_failure2_message ...
ca_WARNS=(1024000 1\ MB)
rafb_WARNS=(800000 800\ kB 10000 http://rafb.net/p/toofast.html "You must wait at least 10 seconds between each paste! Try again in 10 seconds." http://rafb.net/p/toobig.html "The paste is too big. Try another service or paste smaller chunks of data.")
# POST data
engines_POST=(EXTRA NICK DESCRIPTION LANGUAGE EXPIRATION CVT_TABS)
ca_POST=(s=Submit+Post name description type expiry "" content)
rafb_POST=("" nick desc lang "" cvt_tabs text)
osl_POST=(paste=Send poster "" format expiry "" code2)
sh_POST=("" poster "" "" "" "" code)
# regexes
ca_REGEX=('s|^\(http://[^/]\+/\)\([0-9]\+\)$|\1raw/\2|' 's|^.*content="[0-9]\+;\(http://[^/]\+/[0-9]\+\)".*$|\1|p')
rafb_REGEX=('s|html\?$|txt|')
osl_REGEX=('s|^\(http://[^/]\+/\)\([0-9]\+\)$|\1pastebin.php?dl=\2|')

### defaults

# The following defaults can be overridden in either /etc/wgetpaste or ~/.wgetpaste.
#
# If add_to_clipboard() is defined as a function in one of those files it will be called with
# the url where your paste can be seen as an argument. You may use xclip, xcut, klipper or
# whatever your window manager provides for adding it to your clipboard.
#
# Likewise if get_from_clipboard() is defined as a function in one of those files it will be
# called to retrieve input from your clipboard when --xcut is used.
for f in {/etc/,~/.}wgetpaste{,/*.bash}; do
	[[ -f $f ]] && . "$f"
done
DEFAULT_NICK=${DEFAULT_NICK:-$(whoami)}
DEFAULT_SERVICE=${DEFAULT_SERVICE:-rafb}
DEFAULT_LANGUAGE=${DEFAULT_LANGUAGE:-Plain Text}
DEFAULT_EXPIRATION=${DEFAULT_EXPIRATION:-1 month}
# setting e.g. DEFAULT_EXPIRATION_${SERVICE} can be used to override the default setting for
# just one service

### usage

usage() {
	cat <<EOF
Usage: ${0} [options] [file[s]]

Options:
    -l, --language LANG           set language (defaults to "${DEFAULT_LANGUAGE}")
    -d, --description DESCRIPTION set description (defaults to "stdin" or filename)
    -n, --nick NICK               set nick (defaults to your username))
    -s, --service SERVICE         set service to use (defaults to "${DEFAULT_SERVICE}")
    -e, --expiration EXPIRATION   set when it should expire (defaults to "${DEFAULT_EXPIRATION}")

    -S, --list-services           list supported pastebin services
    -L, --list-languages          list languages supported by the specified service
    -E, --list-expiration         list expiration setting supported by the specified service

    -c, --command COMMAND         paste COMMAND and the output of COMMAND
    -i, --info                    append the output of \`${INFO_COMMAND}\`
    -I, --info-only               paste the output of \`${INFO_COMMAND}\` only
    -x, --xcut                    read input from clipboard (requires configuration)

    -r, --raw                     show url for the raw paste (no syntax highlighting or html)
    -v, --verbose                 show wget stderr output if no url is received
        --debug                   be *very* verbose (implies -v)

    -h, --help                    show this help
        --version                 show version information

Defaults (DEFAULT_{NICK,SERVICE,LANGUAGE,EXPIRATION}[_\${SERVICE}]) can be overridden
globally in /etc/wgetpaste{,/*.bash} or per user in ~/.wgetpaste{,/*.bash}.
EOF
}

### show functions

show() {
	echo "${1:0:1}${2:1}s supported by $(getrecipient) (case sensitive):"
	local nr extra
	eval "nr=\"\${#${ENGINE}_${1}[@]}\""
	[[ EXPIRATIONS == $1 ]] && eval "extra=\"\${${SERVICE}[3]}\""
	[[ 0 = $nr ]] && echo -e "\n${extra}\"${SERVICE}\" has no support for setting ${2% *}." >&2
	for ((i=0; i<${nr}; i++)); do
		eval "echo \"    \${${ENGINE}_${1}[i]}\""
	done | ${3:-cat}
}

show_services() {
	echo "Services supported: (case sensitive):"
	local max arg IND INDV engine url
	max=0
	for arg in "${SERVICES[@]}"; do
		[[ ${#arg} -gt $max ]] && max=${#arg}
	done
	((IND=6+${max}))
	if [[ $VERBOSE ]]; then
		max=0
		for s in "${SERVICES[@]}"; do
			eval "arg=\"\${${s}[1]}\""
			[[ ${#arg} -gt $max ]] && max=${#arg}
		done
		((INDV=3+${max}+${IND}))
	fi
	for ((i=0; i<${#SERVICES[*]}; i++)); do
		[[ $VERBOSE ]] && eval "engine=$'\e'\"[${INDV}G- \${${SERVICES[i]}[0]}\""
		eval "url=\"\${${SERVICES[i]}[1]}\""
		echo -e "    ${SERVICES[i]} \e[${IND}G- ${url}${engine}"
	done | sort
}

### verify functions

verify_service() {
	for s in "${SERVICES[@]}"; do
		[[ $s == $* ]] && return 0
	done
	echo -e "\"$*\" is not a supported service.\n" >&2
	show_services >&2
	exit 1
}

verify() {
	local nr
	eval "nr=\"\${#${ENGINE}_${1}S[@]}\""
	if [[ $nr -gt 0 ]]; then
		for ((i=0; i<${nr}; i++)); do
			if [[ $(eval "echo \"\${${1}}\"") == $(eval "echo \"\${${ENGINE}_${1}S[i]}\"") ]]; then
				if [[ -n $(eval "echo \"\${${ENGINE}_${1}_COUNT}\"") ]]; then
					((i++))
					eval "${1}=\"${i}\""
				elif [[ -n $(eval "echo \"\${${ENGINE}_${1}_VALUES}\"") ]]; then
					eval "${1}=\"\${${ENGINE}_${1}_VALUES[i]}\""
				fi
				return 0
			fi
		done
	else
		[[ $(eval "echo \"\${${1}_SET}\"") = 0 ]] || return 0
	fi
	echo -e "\"$(eval "echo \"\${${1}}\"")\" is not a supported ${2} for $(getrecipient).\n" >&2
	show ${1}S "$2" >&2
	exit 1
}

### Posting helper functions

# get the url to post to for any given service
getrecipient() {
	local target serv recip
	if [[ RAW == $1 ]]; then
		eval "target=\"\${${SERVICE}[2]}\""
	else
		serv="${SERVICE}: "
	fi
	for s in "${SERVICES[@]}"; do
		[[ $s == $SERVICE ]] && eval "recip=\"\${${s}[1]}\"" && echo "${serv}${recip}${target}" && return 0
	done
	die "Failed to get url for \"${SERVICE}\"."
}

# print a warning if failure is predictable due to the mere size of the paste. sh seems to be the most reliable
# service in that regard. note that this is only a warning printed. it does not abort.
warnsize() {
	warn() {
		if [[ -n $2 && $1 -gt $2 ]]; then
			echo "Pasting > ${3} often tend to fail with ${SERVICE}. Use --verbose or --debug to see the"
			echo "error output from wget if it fails. Alternatively use another pastebin service like e.g. sh."
		fi
	}
	warn "$SIZE" "$(eval "echo \"\${${ENGINE}_WARNS[0]}\"")" "$(eval "echo \"\${${ENGINE}_WARNS[1]}\"")"
	local LIMIT_LINES=$(eval "echo \"\${${ENGINE}_WARNS[2]}\"")
	warn "$LINES" "$LIMIT_LINES" "${LIMIT_LINES} lines"
}

postdata() {
	local extra field content
	[[ 7 = $(eval "echo \"\${#${ENGINE}_POST[*]}\"") ]] || die "\"${SERVICE}\" is not supported by ${FUNCNAME}()."
	eval "extra=\"\${${ENGINE}_POST[0]}\""
	[[ -n $extra ]] && echo -n "${extra}&"
	for ((i=1; i<6; i++)); do
		eval "field=\"\${${ENGINE}_POST[i]}\""
		[[ -z $field ]] && continue
		eval "content=\"\${${engines_POST[i]}}\""
		echo -n "${field}=${content}&"
	done
	eval "field=\"\${${ENGINE}_POST[i]}\""
	echo "${field}=${INPUT}"
}

geturl() {
	local regex
	eval "regex=\"\${${ENGINE}_REGEX[1]}\""
	if [[ -n $regex ]]; then
		[[ needstdout == $1 ]] && return 0
		sed -n "$regex" <<< "$*"
	else
		[[ needstdout == $1 ]] && return 1
		sed -n 's|^.*Location:\ \(http://[^\ ]\+\).*$|\1|p' <<< "$*"
	fi
}

# verify that the pastebin service did not return a known error url or print a helpful error message
verifyurl() {
	local urls i known
	eval "urls=\"\${#${ENGINE}_WARNS[@]}\""
	(( urls=(${urls}-3)/2 ))
	for((i=0;i<urls;i++)); do
		eval "known=\"\${${ENGINE}_WARNS[3+2*i]}\""
		[[ -n $known && $known == $URL ]] && die "$(eval "echo \"\${${ENGINE}_WARNS[4+2*i]}\"")"
	done
}

# if possible convert URL to raw
convert_to_raw() {
	local convert
	eval "convert=\"\${${ENGINE}_REGEX[0]}\""
	if [[ -n $convert ]]; then
		RAWURL=$(sed -e "$convert" <<< "${URL}")
		return 0
	fi
	echo "Raw download of pastes is not supported by $(getrecipient)." >&2
	return 1
}

### read cli options

# convert groups of short options to singular short options. convert long options to short options.
while [[ -n $1 ]]; do
	case "$1" in
		-- )
		for arg in "$@"; do
			ARGS[${#ARGS[*]}]="$arg"
		done
		break
		;;
		--debug )
		set -x
		DEBUG=0
		;;
		--*=* )
		ARGS[${#ARGS[*]}]="${1%%=*}"
		ARGS[${#ARGS[*]}]="${1#*=}"
		;;
		--* )
		ARGS[${#ARGS[*]}]="$1"
		;;
		-* )
		for shortarg in $(sed 's|.| -&|g' <<< "${1#-}"); do
			ARGS[${#ARGS[*]}]="$shortarg"
		done
		;;
		* )
		ARGS[${#ARGS[*]}]="$1"
	esac
	shift
done

# set the converted options as input
set -- "${ARGS[@]}"

noargument() {
	die "${0}: option ${1} requires an argument"
}

getfilenames() {
	for f in "$@"; do
		[[ -f $f ]] || die "${0}: ${f} No such file found."
		SOURCE="files"
		FILES[${#FILES[*]}]="$f"
	done
}

while [[ -n $1 ]]; do
	case "$1" in
		-- )
		shift && getfilenames "$@" && break
		;;
		-c | --command )
		[[ -z $2 ]] && noargument "$1"
		SOURCE="command"
		COMMANDS[${#COMMANDS[*]}]="$2"
		shift 2
		;;
		-d | --description )
		[[ -z $2 ]] && noargument "$1"
		DESCRIPTION="$2"
		shift 2
		;;
		-e | --expiration )
		[[ -z $2 ]] && noargument "$1"
		EXPIRATION_SET=0
		EXPIRATION="$2"
		shift 2
		;;
		-E | --list-expiration )
		LIST_EXPIRATION=0
		shift
		;;
		-h | --help )
		usage && exit 0
		;;
		-i | --info )
		INFO=0
		shift
		;;
		-I | --info-only )
		SOURCE="info"
		shift
		;;
		-l | --language )
		[[ -z $2 ]] && noargument "$1"
		LANGUAGE_SET=0
		LANGUAGE="$2"
		shift 2
		;;
		-L | --list-languages )
		LIST_LANGUAGES=0
		shift
		;;
		-n | --nick )
		[[ -z $2 ]] && noargument "$1"
		NICK=$(escape "$2")
		shift 2
		;;
		-r | --raw )
		RAW=0
		shift
		;;
		-s | --service )
		[[ -z $2 ]] && noargument "$1"
		verify_service "$2"
		SERVICE=$(escape "$2")
		shift 2
		;;
		-S | --list-services )
		SHOW_SERVICES=0
		shift
		;;
		-v | --verbose )
		VERBOSE=0
		shift
		;;
		--version )
		echo "${0}, version ${VERSION}" && exit 0
		;;
		-x | --xcut )
		SOURCE="xcut"
		shift
		;;
		-* )
		die "${0}: unrecognized option \`${1}'"
		;;
		*)
		getfilenames "${1}" && shift
		;;
	esac
done

### everything below this should be independent of which service is being used...

# show services if requested (need to respect --verbose if specified)
[[ $SHOW_SERVICES ]] && show_services && exit 0

# set default service, nick, source and tabs convertion
SERVICE=${SERVICE:-${DEFAULT_SERVICE}}
eval "ENGINE=\"\${${SERVICE}[0]}\""
[[ -n $(eval "echo \"\${DEFAULT_NICK_${SERVICE}}\"") ]] && NICK=${NICK:-$(eval "echo \"\${DEFAULT_NICK_${SERVICE}}\"")}
NICK=${NICK:-$(escape "${DEFAULT_NICK}")}
[[ -z $SOURCE ]] && SOURCE="stdin" && FILES[${#FILES[*]}]="/dev/stdin"
CVT_TABS="No"

# show languages if requested (needs to be done after the right service is selected)
[[ $LIST_LANGUAGES ]] && show LANGUAGES language sort && exit 0

# show expiration options if requested (needs to be done after the right service is selected)
[[ $LIST_EXPIRATION ]] && show EXPIRATIONS "expiration option" && exit 0

# language needs to be verified before it is escaped but after service is selected
[[ -n $(eval "echo \"\${DEFAULT_LANGUAGE_${SERVICE}}\"") ]] && LANGUAGE=${LANGUAGE:-$(eval "echo \"\${DEFAULT_LANGUAGE_${SERVICE}}\"")}
LANGUAGE=${LANGUAGE:-${DEFAULT_LANGUAGE}}
# uses ${SERVICE} and ${LANGUAGE}. may change the value of the latter.
verify LANGUAGE language
LANGUAGE=$(escape "${LANGUAGE}")

# expiration needs to be verified before it is escaped but after service is selected
[[ -n $(eval "echo \"\${DEFAULT_EXPIRATION_${SERVICE}}\"") ]] && EXPIRATION=${EXPIRATION:-$(eval "echo \"\${DEFAULT_EXPIRATION_${SERVICE}}\"")}
EXPIRATION=${EXPIRATION:-${DEFAULT_EXPIRATION}}
# uses ${SERVICE} and ${EXPIRATION}. may change the value of the latter.
verify EXPIRATION "expiration option"
EXPIRATION=$(escape "${EXPIRATION}")

# set prompt
if [[ 0 -eq $UID ]]; then
	PS1="#"
else
	PS1="$"
fi

# set default description
if [[ -z $DESCRIPTION ]]; then
	case "$SOURCE" in
		info )
		DESCRIPTION="${PS1} ${INFO_COMMAND};"
		;;
		command )
		DESCRIPTION="$PS1"
		for c in "${COMMANDS[@]}"; do
			DESCRIPTION="${DESCRIPTION} ${c};"
		done
		;;
		files )
		DESCRIPTION="${FILES[*]}"
		;;
		* )
		DESCRIPTION="$SOURCE"
		;;
	esac
fi

# read input
case "$SOURCE" in
	command )
	for c in "${COMMANDS[@]}"; do
		INPUT="${INPUT}${PS1} ${c}"$'\n'"$(bash -c "$c" 2>&1)"$'\n\n'
	done
	;;
	info )
	INPUT="${PS1} ${INFO_COMMAND}"$'\n'"$(${INFO_COMMAND} ${INFO_ARGS})"
	;;
	xcut )
	if [[ function == $(type -t get_from_clipboard) ]]; then
		INPUT="$(get_from_clipboard)"
	else
		cat <<EOF
You need to define get_from_clipboard() in /etc/wgetpaste or ~/.wgetpaste to use
--xcut. If you want to use e.g. xclip simply emerge xclip and define it like this:

get_from_clipboard() {
	xclip -o
}

Likewise if you want the resulting url stored in your clipboard using e.g. xclip
define it like this:

add_to_clipboard() {
	xclip "\$*"
}

You may use whatever your window manager provides to alter your clipboard instead
of xclip.
EOF
		exit 1
	fi
	;;
	files | stdin )
	# handle the case where the input source (defaulting to /dev/stdin) is not readable verbosely
	if [[ ${#FILES[*]} -gt 1 ]]; then
		for f in "${FILES[@]}"; do
			[[ -r $f ]] || \
				die "The input source: \"${f}\" is not readable. Please specify a readable input source."
			INPUT="${INPUT}${PS1} cat ${f}"$'\n'"$( < "$f" )"$'\n\n'
		done
	else
		INPUT=$( < "$FILES" )
	fi
	;;
esac
[[ -z $INPUT ]] && die "No input read. Nothing to paste. Aborting."

# append ${INFO_COMMAND} if needed
if [[ $INFO ]]; then
	DESCRIPTION="${DESCRIPTION} ${PS1} ${INFO_COMMAND};"
	INPUT="${INPUT}"$'\n'"${PS1} ${INFO_COMMAND}"$'\n'"$(${INFO_COMMAND} ${INFO_ARGS})"
fi

# escape DESCRIPTION and INPUT
DESCRIPTION=$(escape "$DESCRIPTION")
INPUT=$(escape "$INPUT")

# print a friendly warning if the size makes failure predictable for the specified pastebin service.
SIZE=$(wc -c <<< "$INPUT")
LINES=$(wc -l <<< "$INPUT")
warnsize >&2

# create temp file (wget is much more reliable reading large input from a file than from the cli directly
TEMPFILE=$(mktemp /tmp/wgetpaste.XXXXXX)
if [[ -f $TEMPFILE ]]; then
    # write paste data to the temporary file
    postdata > "$TEMPFILE" || die "Failed to write to temporary file: \"${TEMPFILE}\"."
    WGET_ARGS="--post-file=${TEMPFILE}"
else
	# fall back to using --post-data if the temporary file could not be created
	# TABs and new lines need to be escaped for wget to interpret it as one string
    WGET_ARGS="--post-data=$(postdata | sed -e 's|$|%0a|g' -e 's|\t|%09|g' | tr -d '\n')"
fi

# set recipient
RECIPIENT=$(getrecipient RAW)

# paste it
WGET_ARGS="--tries=5 --timeout=60 ${WGET_ARGS}"
if geturl needstdout || [[ $DEBUG || ! -w /dev/null ]]; then
	OUTPUT=$(LC_ALL=C wget -O - ${WGET_ARGS} ${RECIPIENT} 2>&1)
else
	OUTPUT=$(LC_ALL=C wget -O /dev/null ${WGET_ARGS} ${RECIPIENT} 2>&1)
fi

# clean temporary file if it was created
if [[ -f $TEMPFILE ]]; then
	if [[ $DEBUG ]]; then
		echo "Left temporary file: \"${TEMPFILE}\" alone for debugging purposes."
	else
		rm "$TEMPFILE" || echo "Failed to remove temporary file: \"${TEMPFILE}\"." >&2
	fi
fi

# get the url
URL=$(geturl "$OUTPUT")

# verify that the pastebin service did not return a known error url such as toofast.html from rafb
# uses ${SERVICE} and ${URL}.
verifyurl

# handle the case when there was no location returned
if [[ -z $URL ]]; then
	if [[ $DEBUG || $VERBOSE ]]; then
		die "Apparently nothing was received. Perhaps the connection failed."$'\n'"$OUTPUT"
	else
		echo "Apparently nothing was received. Perhaps the connection failed. Enable --verbose or" >&2
		die "--debug to get the output from wget that can help diagnose it correctly."
	fi
fi

# convert_to_raw() may change the value of RAW. Otherwise it set RAWURL.
if [[ $RAW ]] && convert_to_raw; then
	showurl "$RAWURL" "raw "
else
	showurl "$URL"
fi

exit 0
